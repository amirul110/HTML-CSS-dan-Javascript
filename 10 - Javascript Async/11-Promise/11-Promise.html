<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title> membuat promise </title>
</head>
<body>
<pre id="output">Loading ....</pre>
<script>
    
    function getBarang() {
        // return di getBarang() itu tujuannya mengembalikan objek Promise ke luar, supaya si pemanggil bisa langsung pakai .then() dan .catch().
        return new Promise(function (resolve, reject) {
            const Kiajax = new XMLHttpRequest();
            Kiajax.open("GET", "status.json")
            Kiajax.onload = function (){
                if (Kiajax.status === 200) {
                    // Mengubah string JSON menjadi objek JavaScript
                    resolve(JSON.parse(Kiajax.responseText))
                } else {
                    reject("Gagal ambil data : " + Kiajax.status)
                }
            }
            Kiajax.onerror = function (){
                reject("terjadi kesahlan jaringan")
            }
            Kiajax.send();
        })
    }

    // apakah Promise ini hanya aktif kalau getBarang() dipanggil?
    getBarang()
        .then(function (result) {
            // berhasil
            //              JSON.stringify = ubah objek js jadi string JSON                                result = objek yang ingin diubah ke text, null = replacer (tdk difilter), 2020 = spasi indentasi buat rapi
            document.getElementById("output").textContent = JSON.stringify(result, null, 2)
        })
        .catch(function (error) {
            // gagal
            document.getElementById("output").textContent = "Error : " + error
        })

    /*
    gambar alur return new Promise

    graph TD
    A[function getBarang()] --> B[return Promise object]
    B --> C[Promise masuk ke .then()]
    C --> D[Proses async di dalam Promise jalan]
    D --> E{Sukses?}
    E -- Ya --> F[resolve(data)] --> G[Panggil .then()]
    E -- Tidak --> H[reject(error)] --> I[Panggil .catch()]


Urutan eksekusi ketika getBarang() dipanggil
Panggil getBarang()

js
Salin kode
getBarang()
JavaScript masuk ke dalam fungsi getBarang.

Buat Promise

js
Salin kode
return new Promise(function (resolve, reject) {
    // callback ini langsung dieksekusi saat Promise dibuat
});
Promise ini langsung memanggil callback (resolve, reject) tadi.

Semua baris di dalamnya (const Kiajax = new XMLHttpRequest(); ...) dijalankan saat itu juga.

Jadi AJAX request mulai dikirim sekarang juga.

Kirim AJAX

js
Salin kode
const Kiajax = new XMLHttpRequest();
Kiajax.open("GET", "status.json");
Kiajax.onload = function() { ... };
Kiajax.onerror = function() { ... };
Kiajax.send();
Setelah send(), fungsi getBarang() langsung selesai dan mengembalikan objek Promise (statusnya masih pending).

Proses request HTTP berjalan di background (asynchronous).

Keluar dari getBarang()
Pemanggil sekarang punya Promise object yang bisa dipakai:

js
Salin kode
getBarang().then(...).catch(...);
Ketika response dari server datang:

Kalau status === 200 → panggil resolve(data) → .then() yang tadi kamu tulis akan dieksekusi.

Kalau status !== 200 atau terjadi error jaringan → panggil reject(error) → .catch() akan dieksekusi
     */
</script>
</body>
</html>
